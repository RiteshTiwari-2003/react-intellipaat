React Life cycle ;

Life Cycle of component :
each component in react has a lifecycle which you can monitor and manipulate during its three main phases:
the three phases are : mounting , updating and unmounting 

1. Mounting ;
mounting means putting elements into dom 
React has four buildin method that gets called int the order when mounting a component :
1. constructor()
2. getDerivedStateFromprops()
3. render()
4. componentdidmount()

the render () method is required and will always be called , the other are optional and will be caled if you define them .

constructor()
constructor is called before anything else when teh component is initiated , and it is the natural place to set up the initial state and other the initial values 
the constructor method is called with the props as a argument 

getderivedstatefromprops()
this method is called right before rendering the element int he dom 
this is the natural place to set the state object based on the initial props 
it takes state as argument and return an object with changes in state 

class Header extends React.Component{
    constructor(props){
        super(props);
        this.state={
            favoirateColor:"red"
        };
    }
    static getDerivedStateFromProps(props,state){
        return {favoirateColor:props.favcol};
    }
    render(){
        return(
            <h1>My favoirate color is {this.state.favoirateColor} </h1>
        )
    }
}
const root=ReactDOM.createRoot(document.getElementbyId("root"));
root.render(<Header favcol="yellow"/>)


3. render() method is always called , this method is required and is the method that actually output the html to the dom 

4. the componentdidmount(); this method is called after render method , this is where you run statement that require that the component is already placed in dom 

the next phase is updating when the component is updating in this phase these built in function come like 
1. getDerivedStateFromprops()
2. shouldcomponentupdate()
3. render()
4. getSanpShotBeforeupdate()
5. componentdidupdate()

the render ethod is required and always be called the other are o[tional] 

3. phase 
unmounting 
the next phase in the lifecycle is when a component is removed from the dom 
react has only one built in function for unmounting phase which is componentwillunmount()

#### Redux 
Redux can be used in any framework 
not just in react it is used in any framework , redux is javascript library for statemanagement 
state is what ? dont confuse , here is we talk about global state not about component state and props talk about application state management 


## ## redux is just action dispatch reducer update the state then again component re render 
redux is a state management library for javascript apps , often used with react.
it provide a single centralized store for the entire application's state 
instead of passing props deeply (props drilling), Redux allow any component to access state directly 
state is updated using action and reducers 

core principle of redux :
    1. single source of truth : one global store for the entire application 
    2. state is read only :
        you can not modify state directly , you must dispatch an action 
        change via pure function : reducer define how state changes when action are dispatched 

redux workflow:
    1. store: hold the global state 
    2. action : a plain js object describing what to do (eg. {type:"INCREMENT"})
    3. reducer : apure function (state,action)=>newState
    4. dispatch ; a way to send action to reducer 
    5. provider ;   a wrapper component that makes the redux store avaialable to all react component .
    6. useSelector/connect: read data from store 
    7. useDispatch/mapDispatchFromprops: send action to store 


implementation in code 
we will make a simple counter app with redux -> increment and decrement 
step A; 
1. install react and redux-react 
npm install redux react-redux 
step B:
    create redux file 
    store.js 
    import {createStore} from "redux";
    const initialState={count:0};
    //reducer
    function counterReducer(state=initialState,action){
        switch(action.type){
            case "INCREMENT":
                return {count:state.count+1}
            case "DECRE<EMT":
                return {count:state.count-1}
            default:
                return state 
        }
    }
    //store 
    const store=createStore(counterReducer)
    export defualt store;

    wrap app with provider 
    ReactDOM.render(<Provider store={store}><App/></Provider>,document.getElementById("root"))


using redux in class based component 
import React,{Component} from "react";
import {connect} from "react-redux";
class CounterClass extends Component{
    render(){
        return(
            <div>
            <h2>Count: {this.props.count}</h2>
            <button onClick={this.props.increment}>Increment</button>
            <button onClick={this.props.decrement}>Decrement</button>
            </div>
        )
    }
}
//map redux state to props 
const mapStateToProps=(state)=>{
    return {count:state.count};
}
//map dispatc action to the props 
const mapDispatchToProps=(dispatch)=>{
    return{
        increment:()=>dispatch({type:"INCREMENT"}),
        decrement:()=>dispatch({type:"DECREMENT"})
    }
}
export default connect(mapStateToProps,mapDispatchToProps)(CounterClass)